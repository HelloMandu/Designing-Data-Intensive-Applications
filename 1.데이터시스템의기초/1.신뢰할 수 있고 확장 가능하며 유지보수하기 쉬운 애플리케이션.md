# 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

오늘날 많은 애플리케이션은 **계산 중심(compute-intensive)** 과는 다르게 **데이터 중심(data-intensive)** 적이다.    
CPU 성능보다 더 큰 문제는 보통 **데이터의 양**, **복잡도**, **변화 속도**이다

많은 애플리케이션은 다음을 필요로 한다
- 애플리케이션에서 다시 데이터를 찾을 수 있게 저장 // **데이터베이스(Database)**
- 읽기 속도 향상을 위해 값비싼 수행 결과를 기억 // **캐시(cache)**
- 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공 // **검색 색인(search index)**
- 비동기 처리를 위해 다른 프로세스로 메시지 보내기 // **스트림 처리(stream processing)**
- 주기적으로 대량의 누적된 데이터를 분석 // **일괄 처리(batch processing)**

![img.png](./image/img.png)

내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면?   
시스템의 일부 성능이 저하되더라도 일관되게 좋은 성능을 제공하려면?   
부하 증가를 다루기 위해 규모를 확장하려면?   
이 책에서는 대부분의 소프트웨어에서 중요하게 여기는 세 가지 관심사에 중점을 둔다
- 신뢰성(Reliability): 하드웨어나 소프트웨어 결함, 인적오류(human error) 같은 **역경**에 직면하더라도 시스템은 지속적으로 **올바르게 동작**(원하는 성능 수준에서 정확한 기능 수행)
- 확장성(Scalability): 시스템의 데이터 양, 트래픽 양, 복잡도가 **증가**하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다
- 유지보수성(Maintainability): 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 **생산적으로** 작업할 수 있어야 한다

## 신뢰성
"올바르게 동작함을 의미하는 경우", 대략 "무언가 잘못되더라고 지속적으로 올바르게 동작함"을 신뢰성의 의미로 이해할 수 있다.

- 애플리케이션은 사용자가 기대한 기능을 수행한다
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다
- 세스템은 허가되지 않은 접근과 오남용을 방지한다

#### 결함과 장애
잘못될 수 있는 일을 **결함(fault)**이라 부른다.   
결함을 예측하고 대처할 수 있는 시스템을 **내결함성(fault-tolerant) 또는 탄력성(resilient)** 을 지녓다고 말한다.
결함은 장애(failure)와 동일하지 않다.  
결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만,    
**장애**는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.

결함 확률을 0으로 줄이는 것은 불가능하다. 따라서 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.   
그렇기 때문에 경고 없이 개별 프로세스를 무작위로 죽이는 것과 같이 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트 한다.


### 하드웨어 결함
장애율을 줄이기 위한 첫 번째 대응으로 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법이 일반적이다.   
최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분은 하드웨어 구성 요소의 중복으로 충분했다.   
하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됬고 이와 비례해 하드웨어 결함율도 증가했다.   
따라서 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 옮겨가고 있다.

### 소프트웨어 오류
- 잘못된 입력의 경우 서버 인스턴스가 죽는 버그
- CPU, 메모리, 디스크, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
- 속도가 느려 반응이 없거나 잘못된 응답을 반환하는 서비스
- 한 요소의 작은 결함이 다른 구성 요소의 결함을 야기하는 연쇄장애

소프트웨어 오류 문제는 신속한 해결책이 없다. 주의 깊은 생각, 빈틈없는 테스트, 프로세스 격리, 프로세스 재시작 허용, 모니터링, 분섣 등 여러 작은 일들이 도움을 줄 수 있다.

### 인적 오류
***사람이 미덥지 않음에도 시스템을 어떻게 신뢰성 있게 만들까?***

- 오류의 가능성을 최소화 하는 방향으로 설계하라. 추상화, API, 인터페이스를 사용하면 "옳은 일"은 쉽게 하고, "잘못된 일"은 막을 수 있다.
- 가장 많이 실수하는 장소에서 장애가 발생할 수 있는 부분을 분리하라. 실제 데이터를 이용해 테스트할 수 있지만, 사용자에게는 영향이 없는 비 프로덕션 샌드박스(sandbox)를 제공하라 // ??? 이게 뭔소리지
- 단위 테스트부터 통합테스트, 수동 테스트까지 철저하게 테스트하라. 자동화된 테스트는 특히 코너 케이스(corner case)를 다루는데 유용하다
- 장애 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
