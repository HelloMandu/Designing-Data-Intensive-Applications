# 복제

복제가 필요한 이유
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

복제 알고리즘
- 단일 리더(single-leader)
- 다중 리더(multi-leader)
- 리더가 없음(leaderless)

## 리더와 팔로워
**복제 서버(replica)** 데이터 베이스의 복사본을 저장하는 각 노드

![img.png](img.png)
#### 리더 기반 복제
=(마스터 슬레이브 복제(master slave replication), 능동/수동 복제(active/passive replication))
- 리더(leader)
    - =마스터, 프라이머리(primary)
    - 클라이언트의 쓰기, 읽기 요청을 처리
    - 쓰기 기록 후 팔로워에게 이를 전달
- 팔로워(follower)
    - =읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby)
    - 리더가 보낸 데이터 변경 로그, 변경 스트림을 전달 받아 데이터 복제본을 갱신
    - 클라이언트의 읽기 요청 만을 처리
- RDBMS, NoSQL, 메시지 브로커 등에 사용
- 장단점
    - 리더가 잘못되고 복구 불가능한 경우 팔로워에 복제되지 않은 쓰기는 유실
    - 클라이언트가 어떤 쓰기를 확인했어도 해당 쓰기의 지속성을 보장할 수 없음
    - 모든 팔로워가 잘못되어도 리더가 쓰기 처리를 계속할 수 있다.
    - 내구성이 약하다는 단점에도 불구하고 다음과 같은 조건 하에 많이 사용된다.
        - 많은 팔로워가 존재하는 경우
        - 노드가 지리적으로 분산된 경우


### 동기식 vs 비동기식 복제
![img_1.png](img_1.png)

- 동기식 복제
    - (그림 5-2) 팔로워1의 경우
    - 리더가 팔로워의 쓰기 수신에 대한 응답을 확인하기 위해 대기한다.
    - 확인이 끝나면 사용자에게 성공을 보고 후 해당 쓰기를 보여준다.
    - 장단점
        - 리더와 팔로워의 일관성(최신 데이터)을 보장한다.
        - 팔로워가 응답하지 않을 시(장애, 결함, 네트워크 등의 문제로) 쓰기가 처리될 수 없다.
        - 리더는 모든 쓰기를 차단(block)하고 팔로워가 사용가능할 때 까지 기다려야 한다.
- 비동기식 복제
    - (그림 5-2) 팔로워2의 경우
    - 리더가 팔로워의 쓰기 수신에 대한 응답을 기다리지 않는다.
    - 일관성은 떨어지지만, 사용자 응답 시간이 짧고 고가용성 제공
- 반동기식(semi-synchronous)
    - 모든 팔로워가 동기식 복제 방식을 사용할 수는 없다. 하나의 노드만 고장나도 전체 시스템이 마비.
    - 팔로워 하나는 동기식, 나머지는 비동기 식으로 구성하는 것을 의미
    - 동기식 팔로워가 사용 불가 시 → 다른 비동기 팔로워가 동기식으로 동작
    - 적어도 두 노드(리더, 동기식 팔로워)에 데이터의 최신 복사본이 존재
    - 완전한 비동기식 리더 기반 복제 방식에서 일반적으로 선택

### 새로운 팔로워 설정

- 새로운 팔로워 설정이 필요한 경우
    - 복제 서버의 수를 늘려야 하는 경우
    - 장애 노드를 대체하는 경우
- Q. 새로운 팔로워의 추가 설정은 어떻게 진행해야 할까?
    - A1. 데이터 파일을 복사한다. (X)
      - 복사하는 와중에도 클라이언트의 쓰기 요청은 계속 발생한다. 파일의 복사본은 유효하지 않은(out-of-date) 데이터를 포함한다.
    - A2. 일관성을 보장하기 위해 데이터베이스를 잠가 잠시동안 쓰기를 막는다. (X)
      - 고가용성 목표에 부합하지 않는다.
    - A3. 다음과 같이 중단 없이 팔로워 설정을 수행한다. (O)
        - 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅샷을 가져온다.
        - 스냅샷을 새로운 팔로워 노드에 복사한다.
        - 이후 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경 내역을 요청한다.
        - 요청한 데이터 변경 미처리분(backlog)을 모두 처리하면 팔로워가 리더를 따라잡았다고 말한다.
        - 이제 팔로워는 리더의 데이터 변경을 처리할 수 있다.
          - 노드 중단 처리
          - 시스템의 모든 노드는 다음과 같은 사유로 중단될 수 있다.

### 노드 중단 처리
- 시스템의 모든 노드는 다음과 같은 사유로 중단될 수 있다.
    - 장애
    - 계획된 유지보수
- 단일 노드는 중단 되더라도 전체 시스템은 중단되지 않고 서비스되어야 한다.
- 개별 노드의 장애애도 전체 시스템이 잘 동작하고 노드 중단의 영향을 최소화하는 것이 목표다.

#### 팔로워 장애: 따라잡기 복구
- 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관
- 팔로워가 죽거나, 네트워크 중단 등으로 복구하는 경우 로그를 이용하여 복구를 시작할 수 있다.
- 로그에서 마지막으로 처리된 트랜잭션을 찾는다.
- 해당 트랜잭션 이후의 데이터 변경 내역을 리더에 요청
- 요청한 변경 내역을 모두 적용하면 리더를 따라잡아 복구가 완료된다.

#### 리더 장애: 장애 복구
- 팔로워 중 하나를 새로운 리더로 승격
- 클라이언트는 새로운 리더로 쓰기를 전송해야 함. → 재설정이 필요하다.
- 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작
- 수동 또는 자동으로 진행한다.


- 자동 장애 복구 과정
    1. 리더가 장애인지 판단
        - 판단할 수 있는 확실한 방법은 없음 → 보통 타임아웃을 사용
        - 노드 간 메시지를 주고 받고 일정시간 응답하지 않는 노드는 죽은 것으로 간주
        - 예외도 존재, 리더가 계획된 유지 보수를 위해 의도적으로 중단되는 경우
    2. 새로운 리더를 선택
        - 복제 노드들이 새로운 리더를 선출
        - 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버가 새로운 리더의 가장 적합한 후보로 지목
    3. 새로운 리더 사용을 위해 시스템을 재설정한다.
        - 클라이언트의 쓰기 요청, 팔로워의 데이터 변경 로그 재설정
        - 이전 리더가 복구되는 경우 이전 리더가 새로운 리더를 인식하고 자신은 팔로워가 된다.
       

- 자동 장애 복구 과정에서의 위험
    - 내구성을 보장하지 않음
        - 비동기식 복제 사용 시 새로운 리더는 이전 리더의 최신 쓰기 중 일부를 받지 못했을 수 있음
        - 이전 리더가 다시 클러스터에 추가되면 해당 최신 쓰기 내역은 어떻게 해야 하는가?
        - 새로운 리더가 이와 충돌하는 쓰기를 받았을 수 있음 → 해당 쓰기를 폐기하는 것이 일반적
        - 클라이언트 입장에서 내구성을 신뢰할 수 없음.
    - Github 실제 사례, MySQL과 Redis 간 데이터 불일치
        - MySQL의 팔로워가 리더로 승격. 이 팔로워가 이전 리더의 쓰기 내역을 완벽히 갱신하지 못함
        - 새로운 리더에는 없고, 이전 리더에만 존재하는 기본키를 레디스에서는 사용하고 있었음.
        - 새로운 팔로워는 이미 할당된 기본키를 재사용 → 레디스와 MySQL간의 데이터 불일치 발생
      - 스플릿 브레인(Split Brain)
          - 특정 결함 시나리오에서 두 노드가 자신이 리더라고 인식
          - 두 리더가 각자 쓰기 요청을 처리하기 때문에 쓰기 충돌이 발생
          - 쓰기 충돌을 해소하지 못하면 데이터가 유실 또는 오염된다.
          - 둘 이상의 리더가 감지되면 하나를 종료하는 메커니즘도 있으나 잘못 설계 시 둘 모두가 종료될 수 있음
      - 죽었다고 판단하기에 적절한 타임아웃 값을 정하기가 어렵다.
          - 너무 길면 → 복구에 너무 오랜 시간이 소요
          - 너무 짧으면 → 불필요한 장애복구 발생
          - 노드의 응답시간은 일시적인 부하 급증, 네트워크 문제 등으로 일정할 수 없다.
          - 시스템이 높은 부하, 네트워크 문제와 씨름 중인 경우 불필요한 장애 복구는 상황을 악화시킬 수 있음.
        
### 복제 로그 구현
- 구문(Statement) 기반 복제
    - 요청받은 구문을 기록하고 쓰기를 실행한 다음 구문을 팔로워에게 전송
        - RDB : INSERT, UPDATE, DELETE …
    - 비결정적인 요인에 의해 복제가 깨질 수 있다.
        - NOW(), RAND() 등은 복제 서버마다 다른 값을 생성할 가능성이 존재
        - 자동증가 컬럼을 사용하거나, 기존 데이터에 의존하는 경우(WHERE) 정확히 같은 순서로 실행되어야 함
        - 순서가 다르면 구문의 효과가 다를 수 있음 → 동시에 여러 트랜잭션이 수행되는 것을 제한한다.
        - 부수효과를 가진 구문의 경우 부수효과가 완벽히 결정적이어야 모든 팔로워에서 그 효과도 동일하다.
    - 리더가 구문 기록 시 비결정적 함수 호출을 고정 값을 반환하도록 대체(하지만 여러 에지 케이스가 있어 현재는 다른 방식을 선호) // what..?


- 쓰기 전 로그(WAL, write-ahead log) 배송
    - 일반적으로 데이터베이스의 모든 쓰기는 로그에 기록이 된다.
    - 리더가 로그를 팔로워에게 전송하고, 팔로워는 이 로그를 처리함으로써 복제한다.
    - 로그는 제일 저수준의 데이터를 기술함
        - 디스크 블록에서 어떤 데이터를 변경했는 지와 같은 상세 정보 포함
        - 복제 프로세스가 저장소 엔진과 밀접하게 연관된다.
        - 리더와 팔로워가 동일한 소프트웨어 버전에서 실행되어야 한다.
        - 소프트웨어 업그레이드 시 중단 시간이 필요하다.


- 논리적(로우 기반) 로그 복제
    - 로그를 저장소 엔진과 분리하기 위한 대안으로 복제와 저장소 엔진에 각기 다른 로그 형식을 사용한다.
    - 논리적 로그(logical log)
        - 복제에서 사용하는 로그를 저장소 엔진의 물리적 데이터 표현과 구별하여 부른다.
        - 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션 커밋을 레코드에 표시
    - 논리적 로그와 저장소 엔진 내부를 분리
        - 하위 호환성을 유지
        - 리더와 팔로워가 각기 다른 버전의 소프트웨어에서 실행 가능
          트리거 기반 복제
          지금까지 설명한 복제 방식은 애플리케이션의 관여 없이 DB 시스템에 의해 구현되었다.


- 트리거 기반 복제
    - 사용자 정의 애플리케이션 코드를 등록할 수 있다.
    - 데이터 변경 시(쓰기 트랜잭션) 자동으로 실행된다.
    - 트리거를 통해 데이터 변경을 분리된 테이블에 로깅한다.
    - 이 테이블에 기록된 데이터 변경을 외부 프로세스가 읽고 처리한다.
    - 필요한 애플리케이션 로직 적용 후 다른 시스템으로 데이터를 복제한다.
    - 장단점
        - 트리거 기반 복제는 다른 복제 방식보다 많은 오버헤드가 있다.
        - 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생한다.
        - 그럼에도 불구하고 유연성 때문에 매우 유용하다.

### 복제 지연 문제

- 읽기 확장(read-scaling) 아키텍처
    - 하나의 리더와 여러 팔로워로 구성
    - 리더: 읽기+쓰기, 팔로워: 읽기
    - 장점
        - 웹 서비스의 경우 읽기 요청이 대부분, 쓰기 요청은 작은 비율로 구성
        - 리더의 부하를 경감하고 복제 서버에서 읽기 요청을 처리
        - 복제의 목표 중 확장성, 지연시간 단축 달성
      - 단점
        - 동기식 복제는 단일 노드의 장애, 네트워크 중단이 전체 시스템의 쓰기를 마비시켜 적절하지 않다.
        - 노드가 많아질 수록 다운될 가능성이 커져 동기식 설정과 적절하지 않다.
    - 일시적인 데이터 불일치와 최종적 일관성
        - 비동기 팔로워에서 데이터를 읽을 경우 지난 데이터를 읽을 수 있음 → 데이터 불일치 발생
        - 불일치는 일시적이다. 결국 팔로워는 리더를 따라잡게 된다. → 최종적 일관성
    > **최종적 일관성 (Eventual Consistency)**   
        분산 컴퓨팅 환경에서 사용되는 일관성 모델 중 하나. 일시적으로는 데이터의 일관성이 깨지는 것을 허용한다.
        그러나 최종적으로는 (데이터의 변경사항이 없다면) 데이터 대한 모든 접근들에 대해 마지막으로 갱신된 값을 반환하는 것을 보장한다.

- 복제 지연
    - 정상적인 경우 복제 지연으로 인한 데이터 불일치는 찰나의 순간이며 크게 문제가 되지 않는다.
    - 시스템이 가용량 근처에서 동작하거나 네트워크 문제가 있다면 복제 지연으로 인한 불일치가 문제가 될 수 있다.

#### 자신이 쓴 내용 읽기
- 쓰기 후 읽기(read-after-write) 일관성
    - 사용자가 페이지를 리로딩하면 자신이 제출한 모든 갱신을 볼수 있음을 보장한다.
    - 다른 사용자가 제출한 것에 대해서는 보장하지 않는다.
![img_2.png](img_2.png)

- 쓰기 후 읽기 일관성 구현하기
    1. 리더 기반 복제 시스템에서 
        - 사용자가 수정한 내용을 읽을 때에는 리더에서 이 외의 경우는 팔로워에서 읽는다.
            - ex. SNS
                - 사용자 프로필은 소유자 자신만 편집이 가능하다. → 자신의 프로필 조회는 리더에서 조회
                - 다른 사용자의 프로필은 팔로워에서 조회
        - 시간을 기준으로 판단하기
            - 레코드의 마지막 갱신 시각을 기준으로(ex. 1분 이내) 리더 읽기 여부를 구분하기
            - 팔로워에서 복제 지연을 모니터링 하여 1분 이상 늦은 팔로워에 대한 질의 금지
        - 클라이언트가 기억하는 가장 최근 쓰기의 타임스탬프를 기억하기
            - 시스템은 팔로워에게 타임스탬프까지 갱신을 반영하도록 할 수 있음
            - 복제서버에 아직 갱신이 반영되지 않았다면?
                - 다른 복제 서버가 읽기 요청을 처리
                - 복제 서버에 갱신이 반영될 때 까지 질의를 대기
            - 타임스탬프는 논리적 의미의 타임스탬프 또는 실제 시스템 시간일 수 있음
        - 복제 서버가 여러 데이터센터에 분산된 경우
            - 리더가 제공해야하는 요청은 전부 리더가 포함된 데이터센터로 라우팅되어야 한다.
    2. 디바이스 간(cross-device) 쓰기 후 읽기 일관성
        - 동일한 사용자가 여러 디바이스(데스크톱 웹 브라우저, 모바일 앱)로 서비스에 접근하는 경우
        - 디바이스 간 쓰기 후 읽기 일관성이 보장되어야 한다.
        - 사용자의 마지막 갱신 타임스탬프의 경우 다른 디바이스에서는 알 수가 없다.
            - 이러한 메타데이터를 중앙집중식으로 관리해야 다른 디바이스에서도 확인이 가능하다.
        - 복제 서버가 여러 데이터센터 간에 분산된 경우
            - 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다.
            - 데스크톱 → 홈 광대역 연결, 모바일 기기 → 셀룰러 데이터 네트워크
            - 각 디바이스의 네트워크 라우팅은 완전히 다르다.
            - 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다.
        
    
#### 단조 읽기
![img_3.png](img_3.png)
- 시간이 거꾸로 흐르는 현상
    - 팔로워 간에도 동일한 쓰기에 대해 갱신 시점의 차이가 존재한다.
    - 어떤 팔로워는 쓰기를 알고 있으나, 어떤 팔로워는 모른다면 시간이 거꾸로 흐르는 현상을 겪을 수 있다.

- **단조 읽기(monotonic read)**
    - 위와 같은 종류의 이상 현상이 발생하지 않음을 보장한다.
    - 강한 일관성 보다는 덜하고, 최종적 일관성 보다는 강한 보장이다.
    - 한 사용자가 여러 번에 걸쳐 읽어도 시간이 되돌아가는 현상을 경험하지 않는다.
    - 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.
    - 달성하는 방법
        - 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되도록 한다.
        - 사용자 ID의 해시를 기반으로 복제 서버를 선택
        - 복제 서버가 고장나면 사용자 질의를 다른 복제 서버로 재라우팅할 필요가 있음

#### 일관된 순서로 읽기

- 대화 
    - 푼스 씨 : 미래에 대해 얼마나 멀리 볼 수 있나요. 케이크 부인?
    - 케이크 부인 : 보통 10초 정도요, 푼스 씨.
- 관찰자 입장
    - 케이크 부인 : 보통 10초 정도요, 푼스 씨.
    - 푼스 씨 : 미래에 대해 얼마나 멀리 볼 수 있나요. 케이크 부인?
![img_4.png](img_4.png)

- 일관된 순서로 읽기(consistence prefix read)
    - 이러한 이상현상을 방지하기 위해 일관된 순서로 읽기와 같은 유형의 보장이 필요
    - 일련의 쓰기가 특정 순서로 발생한 경우 다른 사용자에게도 쓰기에 대해 쓰여진 순서대로 읽는 것을 보장
    - 인과성의 위반
        - **파티셔닝(샤딩)**된 데이터베이스에서 발생하는 특징적인 문제
        - 많은 분산 데이터베이스에서 파티션은 서로 독립적으로 동작 → 쓰기의 전역 순서가 없음
        - 한 가지 해결책은 서로 인과성이 있는 쓰기에 대해 동일한 파티션에 기록되도록 하는 방법
        - 그러나 일부 애플리케이션에서 효율적이지 않음
        - 인과성을 명시하기 위한 알고리즘 → 이후(이전 발생 관계와 동시성)에 다룰 예정

#### 복제 지연을 위한 해결책
- 쓰기 후 읽기와 같은 강한 보장을 제공하도록 시스템을 설계
    - 비동기식 복제를 사용하지만 동기식 방식으로 동작하는 것 처럼 보인다.
- 애플리케이션이 데이터베이스보다 더 강력한 보장을 제공하는 방법도 있다.
    - ex. 특정 종류의 리더에서 읽기를 수행
    - 그러나 애플리케이션에서 다루기에는 복잡하여 잘못되기 쉽다.



